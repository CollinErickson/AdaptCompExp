% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptconcept2_sFFLHD_R6.R
\docType{class}
\name{adapt.concept2.sFFLHD.R6}
\alias{adapt.concept2.sFFLHD.R6}
\title{Class providing object with methods for adapt.concept2.sFFLHD.R6}
\format{\code{\link{R6Class}} object.}
\value{
Object of \code{\link{R6Class}} with methods for running an
adaptive experiment.
}
\description{
Class providing object with methods for adapt.concept2.sFFLHD.R6

Class providing object with methods for adapt.concept2.sFFLHD.R6
}
\section{Methods}{

\describe{
  \item{Documentation}{For full documentation of each method go to
  https://github.com/CollinErickson/DOE-Code}
  \item{\code{new(X, Z, corr="Gauss", verbose=0, separable=T,
  useC=F,useGrad=T,
         parallel=T, nug.est=T, ...)}}{This method is used to create object
         of this class with \code{X} and \code{Z} as the data.}

  \item{\code{update(Xnew=NULL, Znew=NULL, Xall=NULL, Zall=NULL,
restarts = 5,
param_update = T, nug.update = self$nug.est)}}{This method updates the
model, adding new data if given, then running optimization again.}
  }
}

\examples{
a <- adapt.concept2.sFFLHD.R6$new(D=2,L=3,func=TestFunctions::gaussian1,obj="desirability",
    des_func=des_func_relmax, n0=12, take_until_maxpvar_below=.9,
    package="GauPro", design='sFFLHD', selection_method="max_des_red",
    alpha_des=1)
a$run(2)


# limnonpoly, grad_norm2_mean, laGP_GauPro_kernel
set.seed(1); ContourFunctions::csa(); a <- adapt.concept2.sFFLHD.R6$new(
  D=2,L=3,func=TestFunctions::limnonpoly, nugget = 1e-7,estimate.nugget = TRUE,
  obj="desirability", des_func=des_func_grad_norm2_mean,
  actual_des_func=NULL,#get_num_actual_des_func_grad_norm2_mean(),
  stage1batches=2, alpha_des=1, weight_const=0,
  package="laGP_GauPro_kernel", design='sFFLHD',
  error_power=2,
  selection_method="max_des_red_all_best"
  # selection_method="ALC_all_best"
); a$run(1)
a$run(2)

}
\keyword{Gaussian}
\keyword{adaptive,}
\keyword{data,}
\keyword{experiments,}
\keyword{process,}
\keyword{regression}
\keyword{sequential,}
\keyword{simulation,}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{X}}{Design matrix}

\item{\code{Z}}{Responses}

\item{\code{b}}{batch size}

\item{\code{func}}{Actual function to get experiment values from}

\item{\code{nb}}{Number of batches, if you know before starting}

\item{\code{D}}{Dimension of data}

\item{\code{mod}}{The GP model from}

\item{\code{func_run_together}}{Whether points should be passed to func separately
as vectors or all together as a matrix whose rows are the points.}

\item{\code{func_fast}}{If the function is fast. If TRUE then full plots are made.
In practice this is alway FALSE.}

\item{\code{new_batches_per_batch}}{How many batches of candidate points are added
for each batch taken.}

\item{\code{X_tracker}}{data.frame tracking the points of X, such as when they were
selected.}

\item{\code{X0}}{An initial matrix of points to be used.}

\item{\code{Xopts}}{A matrix of candidate (option) points.}

\item{\code{Xopts_tracker}}{A data.frame tracking the points of Xopts.}

\item{\code{batch.tracker}}{Tracks when points were added to Xopts.}

\item{\code{Xopts_removed}}{A matrix of points removed from Xopts.}

\item{\code{s}}{The design object for generating candidate points.}

\item{\code{design}}{A string saying which design object should be used.}

\item{\code{stats}}{A data.frame giving stats for each iteration.}

\item{\code{iteration}}{The current iteration.}

\item{\code{obj}}{A string saying what the objective is.}

\item{\code{obj_func}}{A function for the objective.}

\item{\code{n0}}{The initial number of points to be selected.}

\item{\code{take_until_maxpvar_below}}{A number, if the proportion of points near
the maximum variance of the GP model, then it will take
space-filling points.}

\item{\code{package}}{Which GP package should be used by IGP}

\item{\code{force_old}}{A number saying how often the oldest candidate points
should be forced into the design.}

\item{\code{force_pvar}}{A number saying how often the points with the highest
predictive variance should be forced into the design.}

\item{\code{des_func}}{The desirability function.}

\item{\code{des_func_fast}}{Whether the des_func is fast for candidate points.}

\item{\code{alpha_des}}{The alpha constant for the weight function.}

\item{\code{actual_des_func}}{The true des func used to evaluate the model,
not known in practice}

\item{\code{weight_const}}{The weight constant in the weight function, usually 1.}

\item{\code{selection_method}}{What the selection method should be.}

\item{\code{parallel}}{Should new values be calculated in parallel?}

\item{\code{verbose}}{How much detail should be printed to the console. 0 is
minimal, 1 is medium, 2 is a lot.}

\item{\code{twoplot}}{If yes, only the two main plots are shown. Default it FALSE.}

\item{\code{cex}}{Size of plot.}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{nb}}{Number of batches, if you know before starting}

\item{\code{twoplot}}{If yes, only the two main plots are shown. Default it FALSE.}

\item{\code{cex}}{Size of plot.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{adapt.concept2.sFFLHD.R6$new()}}
\item \href{#method-run}{\code{adapt.concept2.sFFLHD.R6$run()}}
\item \href{#method-run1}{\code{adapt.concept2.sFFLHD.R6$run1()}}
\item \href{#method-add_data}{\code{adapt.concept2.sFFLHD.R6$add_data()}}
\item \href{#method-update_obj_nu}{\code{adapt.concept2.sFFLHD.R6$update_obj_nu()}}
\item \href{#method-update_mod}{\code{adapt.concept2.sFFLHD.R6$update_mod()}}
\item \href{#method-update_stats}{\code{adapt.concept2.sFFLHD.R6$update_stats()}}
\item \href{#method-mse_func}{\code{adapt.concept2.sFFLHD.R6$mse_func()}}
\item \href{#method-plot_mean}{\code{adapt.concept2.sFFLHD.R6$plot_mean()}}
\item \href{#method-plot_se}{\code{adapt.concept2.sFFLHD.R6$plot_se()}}
\item \href{#method-plot_abserr}{\code{adapt.concept2.sFFLHD.R6$plot_abserr()}}
\item \href{#method-plot_mse}{\code{adapt.concept2.sFFLHD.R6$plot_mse()}}
\item \href{#method-plot_iwe}{\code{adapt.concept2.sFFLHD.R6$plot_iwe()}}
\item \href{#method-plot_ppu}{\code{adapt.concept2.sFFLHD.R6$plot_ppu()}}
\item \href{#method-plot_des_v_acc}{\code{adapt.concept2.sFFLHD.R6$plot_des_v_acc()}}
\item \href{#method-plot_y_acc}{\code{adapt.concept2.sFFLHD.R6$plot_y_acc()}}
\item \href{#method-plot_1D}{\code{adapt.concept2.sFFLHD.R6$plot_1D()}}
\item \href{#method-plot_2D}{\code{adapt.concept2.sFFLHD.R6$plot_2D()}}
\item \href{#method-plot1}{\code{adapt.concept2.sFFLHD.R6$plot1()}}
\item \href{#method-add_new_batches_to_Xopts}{\code{adapt.concept2.sFFLHD.R6$add_new_batches_to_Xopts()}}
\item \href{#method-Xopts_tracker_add}{\code{adapt.concept2.sFFLHD.R6$Xopts_tracker_add()}}
\item \href{#method-Xopts_tracker_remove}{\code{adapt.concept2.sFFLHD.R6$Xopts_tracker_remove()}}
\item \href{#method-select_new_points_from_old_or_pvar}{\code{adapt.concept2.sFFLHD.R6$select_new_points_from_old_or_pvar()}}
\item \href{#method-select_new_points_from_SMED}{\code{adapt.concept2.sFFLHD.R6$select_new_points_from_SMED()}}
\item \href{#method-select_new_points_from_max_des}{\code{adapt.concept2.sFFLHD.R6$select_new_points_from_max_des()}}
\item \href{#method-select_new_points_from_max_des_red}{\code{adapt.concept2.sFFLHD.R6$select_new_points_from_max_des_red()}}
\item \href{#method-int_werror_after_adding}{\code{adapt.concept2.sFFLHD.R6$int_werror_after_adding()}}
\item \href{#method-add_newL_points_to_design}{\code{adapt.concept2.sFFLHD.R6$add_newL_points_to_design()}}
\item \href{#method-calculate_Z}{\code{adapt.concept2.sFFLHD.R6$calculate_Z()}}
\item \href{#method-weight_func}{\code{adapt.concept2.sFFLHD.R6$weight_func()}}
\item \href{#method-werror_func}{\code{adapt.concept2.sFFLHD.R6$werror_func()}}
\item \href{#method-intwerror_func}{\code{adapt.concept2.sFFLHD.R6$intwerror_func()}}
\item \href{#method-int_pvar_red_for_opts}{\code{adapt.concept2.sFFLHD.R6$int_pvar_red_for_opts()}}
\item \href{#method-int_pvar_red_for_one}{\code{adapt.concept2.sFFLHD.R6$int_pvar_red_for_one()}}
\item \href{#method-actual_intwerror_func}{\code{adapt.concept2.sFFLHD.R6$actual_intwerror_func()}}
\item \href{#method-print_results}{\code{adapt.concept2.sFFLHD.R6$print_results()}}
\item \href{#method-delete}{\code{adapt.concept2.sFFLHD.R6$delete()}}
\item \href{#method-clone}{\code{adapt.concept2.sFFLHD.R6$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Create a new adapt concept object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$new(
  D,
  L,
  b = NULL,
  package = NULL,
  obj = NULL,
  n0 = 0,
  stage1batches = NULL,
  force_old = 0,
  force_pvar = 0,
  useSMEDtheta = F,
  func,
  func_run_together = FALSE,
  func_fast = TRUE,
  take_until_maxpvar_below = NULL,
  design = "sFFLHD",
  selection_method,
  X0 = NULL,
  Xopts = NULL,
  des_func,
  des_func_fast = TRUE,
  alpha_des = 1,
  new_batches_per_batch = 5,
  parallel = FALSE,
  parallel_cores = "detect",
  nugget = 1e-06,
  estimate.nugget = TRUE,
  verbose = 1,
  design_seed = numeric(0),
  weight_const = 0,
  error_power = 1,
  nconsider = Inf,
  nconsider_random = 0,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{D}}{Number of input dimensions. Should all be 0 to 1.}

\item{\code{L}}{Batch size}

\item{\code{b}}{Batch size to add each iteration}

\item{\code{package}}{Gaussian process model package to use}

\item{\code{obj}}{Objective type}

\item{\code{n0}}{Number of points to start experiment with}

\item{\code{stage1batches}}{Number of batches to be run in "stage 1,"
aka nonadaptively, chosen to be space filling}

\item{\code{force_old}}{Proportion of points to be force added
from Xopts because they are old.}

\item{\code{force_pvar}}{Proportion of points to be force added
from Xopts because they have highest predictive variance}

\item{\code{useSMEDtheta}}{Should theta be used when SMED is used?
Theta is the correlation parameter in each dimension. Helps
space things properly}

\item{\code{func}}{The true function. Should take a matrix as input with
D columns, each row is an X point. Or just each point as a vector,
depends on func_run_together}

\item{\code{func_fast}}{Is func, the true function, fast to evaluate? If yes,
will be run repeatedly to calculate true MSE. Never true in practice.}

\item{\code{take_until_maxpvar_below}}{If given, nonadaptive batches will
be taken instead of adaptive until max pvar is below this value.}

\item{\code{design}}{The design to take candidate points from.}

\item{\code{selection_method}}{How should points be selected?}

\item{\code{X0}}{If given, an initial matrix of points that have already
been evaluated.}

\item{\code{Xopts}}{If given, the initial set of Xopts, the candidate
points from which points can be selected.}

\item{\code{des_func}}{The desirability function}

\item{\code{des_func_fast}}{Same as func_fast but for des_func}

\item{\code{alpha_des}}{Alpha value for the desirability function}

\item{\code{new_batches_per_batch}}{Each time a batch is added,
how many batches of points should be added as candidates}

\item{\code{parallel}}{Should points be evaluated in parallel}

\item{\code{parallel_cores}}{Number of parallel cores to be used.}

\item{\code{error_power}}{Power to put the error to. Either 0, 1, or c(0,1).}

\item{\code{nconsider}}{Number of points to consider when adding each
point of the batch.
Designed to be reduced as you go. E.g., adding a batch of 3, you could
use c(Inf, 50, 20) to reduce computation as you go. It would keep the
50/20 best from the previous iteration in consideration.}

\item{\code{nconsider_random}}{If using nconsider, how many random points
should be added back in each iteration?}

\item{\code{...}}{You can pass in actual_des_func like this.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run"></a>}}
\subsection{Method \code{run()}}{
Run multiple iterations
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$run(maxit, plotlastonly = F, noplot = F)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{maxit}}{Number of iterations to run}

\item{\code{plotlastonly}}{Should the plots only be made
after the last iteration (when maxit>1)}

\item{\code{noplot}}{Should plots not be made after any iteration?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run1"></a>}}
\subsection{Method \code{run1()}}{
Run a single iteration
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$run1(plotit = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{plotit}}{Should the plots be made for this iteration?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-add_data"></a>}}
\subsection{Method \code{add_data()}}{
Add data from Xopts to X
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$add_data()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update_obj_nu"></a>}}
\subsection{Method \code{update_obj_nu()}}{
Update nu for objective
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$update_obj_nu(Xnew, Znew)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Xnew}}{Matrix of X points}

\item{\code{Znew}}{Corresponding function values}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update_mod"></a>}}
\subsection{Method \code{update_mod()}}{
Update the GP model on all the data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$update_mod()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update_stats"></a>}}
\subsection{Method \code{update_stats()}}{
Update stats after every iteration
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$update_stats()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mse_func"></a>}}
\subsection{Method \code{mse_func()}}{
Calculate mean squared error using random sample
of points. Only works when func_fast is TRUE and the
true function func is given.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$mse_func()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_mean"></a>}}
\subsection{Method \code{plot_mean()}}{
Contour plot of the predicted mean. Only for 2D input.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_mean(cex = 1, plot.axes = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cex}}{Size parameter}

\item{\code{plot.axes}}{Should the axes included in the plot.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_se"></a>}}
\subsection{Method \code{plot_se()}}{
Contour plot of the predicted standard error. Only for 2D input.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_se(cex = 1, plot.axes = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cex}}{Size parameter}

\item{\code{plot.axes}}{Should the axes included in the plot.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_abserr"></a>}}
\subsection{Method \code{plot_abserr()}}{
Contour plot of the absolute error. Only for 2D input.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_abserr(cex = 1, plot.axes = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cex}}{Size parameter}

\item{\code{plot.axes}}{Should the axes included in the plot.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_mse"></a>}}
\subsection{Method \code{plot_mse()}}{
Plot MSE and PVar over iterations
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_mse(statsdf, cex = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{statsdf}}{DF with stats for points}

\item{\code{cex}}{Size parameter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_iwe"></a>}}
\subsection{Method \code{plot_iwe()}}{
Plot integrate weighted error
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_iwe(statsdf, cex = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{statsdf}}{DF with stats for each point}

\item{\code{cex}}{Size parameter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_ppu"></a>}}
\subsection{Method \code{plot_ppu()}}{
Plot percentage of points used by iteration
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_ppu(statsdf, cex)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{statsdf}}{data frame with stats of when points were taken}

\item{\code{cex}}{Size parameter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_des_v_acc"></a>}}
\subsection{Method \code{plot_des_v_acc()}}{
Plot desirability vs prediction accuracy
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_des_v_acc(cex, cex.axis)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cex}}{Size parameter}

\item{\code{cex.axis}}{Size parameter for axis}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_y_acc"></a>}}
\subsection{Method \code{plot_y_acc()}}{
Plot predicted vs actual with error bars
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_y_acc(residual = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{residual}}{Should residuals be plotted?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_1D"></a>}}
\subsection{Method \code{plot_1D()}}{
Plot for experiments with 1D input
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_1D()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_2D"></a>}}
\subsection{Method \code{plot_2D()}}{
Plot for experiments with 2D input
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot_2D(twoplot = FALSE, cex = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{twoplot}}{Should only predicted surface
and predicted error be shown, or more plots?}

\item{\code{cex}}{Size parameter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot1"></a>}}
\subsection{Method \code{plot1()}}{
Plot at one instance
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$plot1(twoplot = FALSE, cex = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{twoplot}}{Should only predicted surface
and predicted error be shown, or more plots?}

\item{\code{cex}}{Size parameter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-add_new_batches_to_Xopts"></a>}}
\subsection{Method \code{add_new_batches_to_Xopts()}}{
Add new batches of points to Xopts matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$add_new_batches_to_Xopts(
  num_batches_to_take = self$new_batches_per_batch
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{num_batches_to_take}}{Number of batches of points
to add to Xopts from the design $s}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Xopts_tracker_add"></a>}}
\subsection{Method \code{Xopts_tracker_add()}}{
Points to add to Xopts_tracker
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$Xopts_tracker_add(Xnew)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Xnew}}{Matrix of points to add}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Xopts_tracker_remove"></a>}}
\subsection{Method \code{Xopts_tracker_remove()}}{
Remove points from Xopts_tracker
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$Xopts_tracker_remove(newL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{newL}}{Vector of indices of points to remove}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-select_new_points_from_old_or_pvar"></a>}}
\subsection{Method \code{select_new_points_from_old_or_pvar()}}{
Select new points from Xopts that are oldest
or have highest predictive variance
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$select_new_points_from_old_or_pvar()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-select_new_points_from_SMED"></a>}}
\subsection{Method \code{select_new_points_from_SMED()}}{
Select new points from Xopts using SMED
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$select_new_points_from_SMED()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-select_new_points_from_max_des"></a>}}
\subsection{Method \code{select_new_points_from_max_des()}}{
Select new points from Xopts with maximum
desirability
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$select_new_points_from_max_des()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-select_new_points_from_max_des_red"></a>}}
\subsection{Method \code{select_new_points_from_max_des_red()}}{
Select new points from Xopts using maximum
reduction in desirability
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$select_new_points_from_max_des_red()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-int_werror_after_adding"></a>}}
\subsection{Method \code{int_werror_after_adding()}}{
Calculate integrated weighted error after adding Xnew
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$int_werror_after_adding(
  Xnew = NULL,
  Znew = NULL,
  Xnew_Xoptsrow = NULL,
  n = 10000,
  int_points = NULL,
  seed = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Xnew}}{New X points}

\item{\code{Znew}}{Z at those new points}

\item{\code{Xnew_Xoptsrow}}{Rows}

\item{\code{n}}{Number of points}

\item{\code{int_points}}{Integration points}

\item{\code{seed}}{Random seed}

\item{\code{...}}{Passed through}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-add_newL_points_to_design"></a>}}
\subsection{Method \code{add_newL_points_to_design()}}{
Add new L points to design
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$add_newL_points_to_design(
  newL = NULL,
  use_X0 = FALSE,
  reason
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{newL}}{Which rows of Xopts to add}

\item{\code{use_X0}}{Should X0 be used?}

\item{\code{reason}}{Reason selected, is logged in summary DF}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-calculate_Z"></a>}}
\subsection{Method \code{calculate_Z()}}{
Evaluate chosen X points using given function
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$calculate_Z(X)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Matrix whose rows are new points to evaluate}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-weight_func"></a>}}
\subsection{Method \code{weight_func()}}{
The weight function 1 + alpha * delta()
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$weight_func(
  ...,
  XX,
  mod = self$mod,
  des_func = self$des_func,
  alpha = self$alpha_des,
  weight_const = self$weight_const
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Forces you to name arguments}

\item{\code{XX}}{input points}

\item{\code{mod}}{GP model}

\item{\code{des_func}}{Desirability function or des values for each XX}

\item{\code{alpha}}{alpha}

\item{\code{weight_const}}{The weight constant}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-werror_func"></a>}}
\subsection{Method \code{werror_func()}}{
The weighted error function sigmahat * (1 + alpha * delta())
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$werror_func(
  ...,
  XX,
  mod = self$mod,
  des_func = self$des_func,
  alpha = self$alpha_des,
  weight_const = self$weight_const,
  weight_func = self$weight_func,
  error_power = self$error_power
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Forces you to name arguments}

\item{\code{XX}}{X points}

\item{\code{mod}}{GP model}

\item{\code{des_func}}{Desirability function}

\item{\code{alpha}}{alpha}

\item{\code{weight_const}}{Weight constant}

\item{\code{weight_func}}{Weight function}

\item{\code{error_power}}{Error power}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-intwerror_func"></a>}}
\subsection{Method \code{intwerror_func()}}{
Calculate integrated weighted error
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$intwerror_func(
  ...,
  XX = NULL,
  N = 10000,
  mod = self$mod,
  des_func = self$des_func,
  alpha = self$alpha_des,
  weight_const = self$weight_const,
  weight_func = self$weight_func,
  error_power = self$error_power
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Forces you to name arguments}

\item{\code{XX}}{Integration points}

\item{\code{N}}{Number of integration points if XX not given}

\item{\code{mod}}{GP model}

\item{\code{des_func}}{Desirability function}

\item{\code{alpha}}{Alpha}

\item{\code{weight_const}}{Weight constant}

\item{\code{weight_func}}{Weight function}

\item{\code{error_power}}{Error power}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-int_pvar_red_for_opts"></a>}}
\subsection{Method \code{int_pvar_red_for_opts()}}{
Calculate integrated predictive variance reduction for
candidate points.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$int_pvar_red_for_opts(
  ...,
  Xopts,
  XX = NULL,
  N = 10000,
  mod = self$mod,
  des_func = self$des_func,
  alpha = self$alpha_des,
  weight_const = self$weight_const,
  weight_func = self$weight_func,
  delta_pvar_func = mean
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Forces you to name arguments}

\item{\code{Xopts}}{Candidate points}

\item{\code{XX}}{Integration points}

\item{\code{N}}{Number of points}

\item{\code{mod}}{GP model}

\item{\code{des_func}}{Desirability function}

\item{\code{alpha}}{Alpha}

\item{\code{weight_const}}{Weight constant}

\item{\code{weight_func}}{Weight function}

\item{\code{delta_pvar_func}}{Delta pvar func}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-int_pvar_red_for_one"></a>}}
\subsection{Method \code{int_pvar_red_for_one()}}{
Calculate the integrated predictive variance reduction
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$int_pvar_red_for_one(
  v,
  X_,
  XX,
  corr_func,
  Kinv,
  s2,
  K_X_XX,
  delta_pvar_func = mean
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Something}

\item{\code{X_}}{Points}

\item{\code{XX}}{Integration points}

\item{\code{corr_func}}{correlation function}

\item{\code{Kinv}}{Inverse of correlation matrix}

\item{\code{s2}}{Variance term}

\item{\code{K_X_XX}}{Correlation between X_ and XX}

\item{\code{delta_pvar_func}}{which function to use}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-actual_intwerror_func"></a>}}
\subsection{Method \code{actual_intwerror_func()}}{
Calculate the actual integrated weighted error
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$actual_intwerror_func(
  ...,
  N = 2000,
  mod = self$mod,
  f = self$func,
  error_power = self$error_power,
  nquantilegroups
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Forces you to name arguments}

\item{\code{N}}{Number of integration points}

\item{\code{mod}}{Model to use that predicts the function f}

\item{\code{f}}{True function you are estimating}

\item{\code{error_power}}{What power should the error be to?
Either 1, 2, or c(1,2)}

\item{\code{nquantilegroups}}{Number of quantile groups.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print_results"></a>}}
\subsection{Method \code{print_results()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$print_results()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-delete"></a>}}
\subsection{Method \code{delete()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$delete()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{adapt.concept2.sFFLHD.R6$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
