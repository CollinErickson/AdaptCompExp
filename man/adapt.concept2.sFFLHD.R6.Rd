% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptconcept2_sFFLHD_R6.R
\docType{class}
\name{adapt.concept2.sFFLHD.R6}
\alias{adapt.concept2.sFFLHD.R6}
\title{Class providing object with methods for adapt.concept2.sFFLHD.R6}
\format{\code{\link{R6Class}} object.}
\usage{
adapt.concept2.sFFLHD.R6
}
\value{
Object of \code{\link{R6Class}} with methods for running an
adaptive experiment.
}
\description{
Class providing object with methods for adapt.concept2.sFFLHD.R6
}
\section{Fields}{

\describe{
\item{\code{X}}{Design matrix}

\item{\code{Z}}{Responses}

\item{\code{b}}{batch size}

\item{\code{func}}{Actual function to get experiment values from}

\item{\code{nb}}{Number of batches, if you know before starting}

\item{\code{D}}{Dimension of data}

\item{\code{Xopts}}{Available points}

\item{\code{X0}}{Initial design}

\item{\code{package}}{Which GP package to use in IGP}

\item{\code{stats}}{List of tracked stats}

\item{\code{iteration}}{Which iteration}

\item{\code{mod}}{The GP model from}

\item{\code{func_run_together}}{Whether points should be passed to func separately
as vectors or all together as a matrix whose rows are the points.}

\item{\code{func_fast}}{If the function is fast. If TRUE then full plots are made.
In practice this is alway FALSE.}

\item{\code{new_batches_per_batch}}{How many batches of candidate points are added
for each batch taken.}

\item{\code{X_tracker}}{data.frame tracking the points of X, such as when they were
selected.}

\item{\code{X0}}{An initial matrix of points to be used.}

\item{\code{Xopts}}{A matrix of candidate (option) points.}

\item{\code{Xopts_tracker}}{A data.frame tracking the points of Xopts.}

\item{\code{batch.tracker}}{Tracks when points were added to Xopts.}

\item{\code{Xopts_removed}}{A matrix of points removed from Xopts.}

\item{\code{s}}{The design object for generating candidate points.}

\item{\code{design}}{A string saying which design object should be used.}

\item{\code{stats}}{A data.frame giving stats for each iteration.}

\item{\code{iteration}}{The current iteration.}

\item{\code{obj}}{A string saying what the objective is.}

\item{\code{obj_func}}{A function for the objective.}

\item{\code{n0}}{The initial number of points to be selected.}

\item{\code{take_until_maxpvar_below}}{A number, if the proportion of points near
the maximum variance of the GP model, then it will take
space-filling points.}

\item{\code{package}}{Which GP package should be used by IGP.}

\item{\code{force_old}}{A number saying how often the oldest candidate points
should be forced into the design.}

\item{\code{force_pvar}}{A number saying how often the points with the highest
predictive variance should be forced into the design.}

\item{\code{des_func}}{The desirability function.}

\item{\code{des_func_fast}}{Whether the des_func is fast for candidate points.}

\item{\code{alpha_des}}{The alpha constant for the weight function.}

\item{\code{actual_des_func}}{The true des func used to evaluate the model,
not known in practice}

\item{\code{weight_const}}{The weight constant in the weight function, usually 1.}

\item{\code{selection_method}}{What the selection method should be.}

\item{\code{parallel}}{Should new values be calculated in parallel?}

\item{\code{verbose}}{How much detail should be printed to the console. 0 is
minimal, 1 is medium, 2 is a lot.}
}}

\section{Methods}{

\describe{
  \item{Documentation}{For full documentation of each method go to
  https://github.com/CollinErickson/DOE-Code}
  \item{\code{new(X, Z, corr="Gauss", verbose=0, separable=T,
  useC=F,useGrad=T,
         parallel=T, nug.est=T, ...)}}{This method is used to create object
         of this class with \code{X} and \code{Z} as the data.}

  \item{\code{update(Xnew=NULL, Znew=NULL, Xall=NULL, Zall=NULL,
restarts = 5,
param_update = T, nug.update = self$nug.est)}}{This method updates the
model, adding new data if given, then running optimization again.}
  }
}

\examples{
a <- adapt.concept2.sFFLHD.R6$new(D=2,L=3,func=TestFunctions::gaussian1,obj="desirability",
    des_func=des_func_relmax, n0=12, take_until_maxpvar_below=.9,
    package="GauPro", design='sFFLHD', selection_method="max_des_red",
    alpha_des=1)
a$run(2)


# limnonpoly, grad_norm2_mean, laGP_GauPro_kernel
set.seed(1); ContourFunctions::csa(); a <- adapt.concept2.sFFLHD.R6$new(
  D=2,L=3,func=TestFunctions::limnonpoly, nugget = 1e-7,estimate.nugget = T,
  obj="desirability", des_func=des_func_grad_norm2_mean,
  actual_des_func=NULL,#get_num_actual_des_func_grad_norm2_mean(),
  stage1batches=2, alpha_des=1, weight_const=0,
  package="laGP_GauPro_kernel", design='sFFLHD',
  error_power=2,
  selection_method="max_des_red_all_best"
  # selection_method="ALC_all_best"
); a$run(1)
a$run(2)

}
\keyword{Gaussian}
\keyword{adaptive,}
\keyword{data,}
\keyword{experiments,}
\keyword{process,}
\keyword{regression}
\keyword{sequential,}
\keyword{simulation,}
